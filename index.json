[{"uri":"https://kyeotic.github.io/raviger/api/useroutes/","title":"useRoutes","tags":[],"description":"","content":" This hook is the main entry point for an application using raviger.\nAPI function useRoutes( routes: { [key: string]: (props: { [k: string]: any }) =\u0026gt; JSX.Element }, options?: { basePath?: string routeProps?: { [k: string]: any } overridePathParams?: boolean matchTrailingSlash?: boolean } ): JSX.Element Basic The first parameter is an object of path keys whose values are functions that return a ReactElement (or null when no match is found). The paths should start with a forward-slash / and then contain literal matches (/base), path variables (/:userId), and a * for catch-all wildcards. Path variables will be provided to the matching route-function.\nimport { useRoutes, Link } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;User id={userId} /\u0026gt; } function NavBar () { return ( \u0026lt;div\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/1\u0026#34;\u0026gt;Tom\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/2\u0026#34;\u0026gt;Jane\u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; ) } export default function App() { let route = useRoutes(routes) return ( \u0026lt;div\u0026gt; \u0026lt;NavBar /\u0026gt; {route} \u0026lt;/div\u0026gt; ) } Using a Base Path The basePath option sets a base path that causes all routes to match as if they had the base path prepended to them. It also sets the base path on the router\u0026rsquo;s context, making it available to hooks and \u0026lt;Link\u0026gt; components lower in matching route\u0026rsquo;s tree.\nimport { useRoutes } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;User id={userId} /\u0026gt; } export default function App() { // For the path \u0026#34;/app/about\u0026#34; the \u0026lt;About\u0026gt; route will match  let route = useRoutes(routes, { basePath: \u0026#39;app\u0026#39; }) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } Sharing Props with routes The routeProps option can be used to pass data to the matching route. This is useful for sharing props that won\u0026rsquo;t appear in the route\u0026rsquo;s path, or reducing duplication in path parameter declarations.\nimport { useRoutes } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: ({ title }) =\u0026gt; \u0026lt;Home title={title} /\u0026gt;, \u0026#39;/about\u0026#39;: ({ title }) =\u0026gt; \u0026lt;About /\u0026gt; } export default function App() { let route = useRoutes(routes, { routeProps: { title: \u0026#39;App\u0026#39; } }) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } This can be combined with the overridePathParams option to provide a value that is used even if a path parameter would match for the route. IN this example if maybeGetUserId returns an ID it will be provided to the \u0026lt;User\u0026gt; component instead of the value from the path.\nimport { useRoutes } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;User id={userId} /\u0026gt; } export default function App() { let userId = maybeGetUserId() let route = useRoutes(routes, { routeProps: { userId }, overridePathParams: true }) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } "},{"uri":"https://kyeotic.github.io/raviger/quickstart/","title":"Quick Start","tags":[],"description":"","content":" Quick Start Getting started with raviger\nInstallation npm i raviger  Quick Start This basic setup shows how to display an \u0026lt;App\u0026gt; component that renders a route based on the current path, with links to different routes.\nimport { useRoutes, Link, useQueryParams } from \u0026#39;raviger\u0026#39; import { Home, About, Users } from \u0026#39;./Pages.js\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;Users id={userId} /\u0026gt; } export default function App() { let route = useRoutes(routes) return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/1\u0026#34;\u0026gt;Tom\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/2\u0026#34;\u0026gt;Jane\u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } "},{"uri":"https://kyeotic.github.io/raviger/api/useredirect/","title":"useRedirect","tags":[],"description":"","content":" This hook causes a browser redirect to occur if its predicateUrl matches.\nAPI export function useRedirect( predicateUrl: string, targetUrl: string, queryParams?: QueryParam | URLSearchParams, replace?: boolean ): void Basic If predicateUrl is the current path, redirect to the targetUrl. queryObj is optional, and uses the same serializer that useQueryParams uses by default. If replace (default: true) it will replace the current URL (back button will skip the predicateUrl).\nimport { useRedirect } from \u0026#39;raviger\u0026#39; function Route () { // Will redirect to \u0026#39;/new\u0026#39; if current path is \u0026#39;/old\u0026#39;  useRedirect(\u0026#39;/old\u0026#39;, \u0026#39;/new\u0026#39;, { name: \u0026#39;kyeotic\u0026#39; }) return \u0026lt;span\u0026gt;Home\u0026lt;/span\u0026gt; } "},{"uri":"https://kyeotic.github.io/raviger/api/","title":"API","tags":[],"description":"","content":" API Explore the raviger API\n"},{"uri":"https://kyeotic.github.io/raviger/api/link/","title":"Link","tags":[],"description":"","content":" A React component for rendering a \u0026lt;a\u0026gt; that uses history navigation for local URLs.\nAPI export interface LinkProps extends React.AnchorHTMLAttributes\u0026lt;HTMLAnchorElement\u0026gt; { // Unlike normal \u0026lt;a\u0026gt;, this property is required  href: string, basePath?: string, linkRef?: React.RefObject\u0026lt;HTMLAnchorElement\u0026gt; } export const Link: React.FC\u0026lt;LinkProps\u0026gt; Basic This component is the preferred method of navigation, alongside the navigate function.\nThis component takes all the same parameters as the built-in \u0026lt;a\u0026gt; tag. It\u0026rsquo;s onClick will be extended to perform local navigation, and if it is inside a component returned from useRoutes it will have the provided basePath preprended to its href.\n\u0026lt;Link href=\u0026#34;/foo\u0026#34;\u0026gt; go to foo \u0026lt;/Link\u0026gt; BasePath If a \u0026lt;Link\u0026gt; component is inside a router context (there is a useRoutes in its parent heirarchy) the basePath will be inherited. You can also provide a basePath as a \u0026lt;Link\u0026gt; prop, which will override an inherited one.\nimport { useRoutes, Link } from \u0026#39;raviger\u0026#39; function Home () { return ( \u0026lt;div\u0026gt; \u0026lt;Link href=\u0026#34;/foo\u0026#34; /\u0026gt; {/* href = /app/foo */} \u0026lt;Link href=\u0026#34;/foo\u0026#34; basePath=\u0026#34;/bar\u0026#34; /\u0026gt; {/* href = /bar/foo */} \u0026lt;/div\u0026gt; ) } const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt; } export default function App() { return useRoutes(routes, { basePath: \u0026#39;app\u0026#39; }) ) } Ref Passing To pass a React ref to the \u0026lt;Link\u0026gt; DOM Node use the linkRef property. This will assign the ref to the internal \u0026lt;a\u0026gt; node. In future version this will become ref and use the standard forwardRef API.\n"},{"uri":"https://kyeotic.github.io/raviger/api/activelink/","title":"ActiveLink","tags":[],"description":"","content":" Like the standard Link component, but with built-in className transormation when a matching path is detected.\nAPI export interface ActiveLinkProps extends LinkProps { activeClass?: string exactActiveClass?: string } export const ActiveLink: React.FC\u0026lt;ActiveLinkProps\u0026gt; Basic Just like \u0026lt;Link\u0026gt;, but with two additional properties for modifying the className\n activeClass If the href matches the start of the current path this will be appended to the \u0026lt;a\u0026gt; className. exactActiveClass If the href matches the cirrent path exactly this will be appended to the \u0026lt;a\u0026gt; className. Stacks with activeClass  \u0026lt;ActiveLink href=\u0026#34;/foo\u0026#34; activeClass=\u0026#34;when-path-is-prefix\u0026#34; exactActiveClass=\u0026#34;when-path-is-exact\u0026#34; \u0026gt; go to foo \u0026lt;/ActiveLink\u0026gt; "},{"uri":"https://kyeotic.github.io/raviger/api/redirect/","title":"Redirect","tags":[],"description":"","content":" A React component for causing a browser redirect\nAPI export interface RedirectProps { to: string replace?: boolean merge?: boolean } export const Redirect: React.FC\u0026lt;RedirectProps\u0026gt; Basic If rendered this component will force a redirect. Usefult as a route function\nimport { useRoutes, Redirect } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: ({ title }) =\u0026gt; \u0026lt;Home title={title} /\u0026gt;, \u0026#39;/about\u0026#39;: ({ title }) =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/redirect\u0026#39;: () =\u0026gt; \u0026lt;Redirect to=\u0026#39;/about\u0026#39; /\u0026gt; } export default function App() { let route = useRoutes(routes) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } By default it will navigate with replace and merge both true.\nreplace If replace is true the redirect will not create a new entry in the history stack. default = true\nmerge If merge is true the redirect will use existing location.hash and location.query values. Useful for rewriting URLs without losing their intended state. default = true\n"},{"uri":"https://kyeotic.github.io/raviger/api/navigate/","title":"navigate","tags":[],"description":"","content":" This function causes programmatic navigation and causes all raviger hooks to re-render. Internally it used by the \u0026lt;Link\u0026gt; component.\nAPI export function navigate(url: string, replace?: boolean): void export function navigate( url: string, query?: QueryParam | URLSearchParams, replace?: boolean ): void Basic the navigate function is intended to be used outside of components to perform page navigation programmatically.\nimport { navigate } from \u0026#39;raviger\u0026#39; export async function createUser () { let user = await createUser() navigate(`/users/${user.id}`) } Normal navigation adds an entry to the browsers history stack, enabling the back button to return to the previous location. To instead change the page without adding to the history stack use the replace option. This is sometimes desirable when creating objects as the creation-page form may no longer be a valid location\nimport { navigate } from \u0026#39;raviger\u0026#39; export async function createUser () { let user = await createUser() navigate(`/users/${user.id}`, true) } Navigating with Query Params To navigate with a serialized query string pass an object as the second parameter.\nimport { navigate } from \u0026#39;raviger\u0026#39; export async function createUser () { let user = await createUser() navigate(`/users/${user.id}` { ref: \u0026#39;create page\u0026#39; }) } "},{"uri":"https://kyeotic.github.io/raviger/api/usequeryparams/","title":"useQueryParams","tags":[],"description":"","content":" A hook for reading and updating the query string parameters on the page. Updates on all URL changes. Returns an array that, much like React\u0026rsquo;s own useState, has a value and a setter function. The value is a parsed querystring object, and the setter takes an object that it will serialize into the query string.\nAPI export function useQueryParams( parseFn?: (query: string) =\u0026gt; QueryParam, serializeFn?: (query: QueryParam) =\u0026gt; string ): [QueryParam, (query: QueryParam, replace?: boolean) =\u0026gt; void] Basic The default parse and serialize functions utilized the browser built-in URLSearchParams. You can provide custom parse and serialize functions to control this behavior.\nimport { useQueryParams } from \u0026#39;raviger\u0026#39; function UserList ({ users }) { const [{ startsWith }, setQuery] = useQueryParams() return ( \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; Filter by Name \u0026lt;input value={startsWith || \u0026#39;\u0026#39;} onChange={(e) =\u0026gt; setQuery({ startsWith: e.target.value})} /\u0026gt; \u0026lt;/label\u0026gt; {users.filter(u =\u0026gt; !startsWith || u.name.startsWith(startsWith).map(user =\u0026gt; ( \u0026lt;p key={user.name}\u0026gt;{user.name}\u0026lt;/p\u0026gt; )))} \u0026lt;/div\u0026gt; ) } Updating the Query with merge The second return value from useQueryParams is a function that updates the query string. By default it overwrites the entire query, but it can merge with the query object by setting the second param to false.\nimport { useQueryParams } from \u0026#39;raviger\u0026#39; function UserList ({ users }) { const [{ startsWith }, setQuery] = useQueryParams() return ( \u0026lt;input value={startsWith || \u0026#39;\u0026#39;} onChange={(e) =\u0026gt; setQuery({ startsWith: e.target.value}, false )} /\u0026gt; ) } The replace: false setting also preserves the location.hash. The intent should be thought of as updating only the part of the URL that the setQuery object describes.\n Warning: using setQuery inside of a useEffect (or other on-mount/on-update lifecycle methods) can result in unwanted navigations, which show up as duplicate entries in the browser history stack.\n Custom serialization and parsing Its possible to override either the querystring serializer, deserializer, or both, by providing functions to useQueryParams. Use a custom wrapper hook to reuse throughout your application.\nimport { useQueryParams } from \u0026#39;raviger\u0026#39; import qs from \u0026#39;qs\u0026#39; export function useCustomQuery() { return useQueryParams(qs.parse, qs.stringify) }  "},{"uri":"https://kyeotic.github.io/raviger/api/usenavigationprompt/","title":"useNavigationPrompt","tags":[],"description":"","content":" This hook causes a confirmation to block navigation.\nAPI export function useNavigationPrompt( predicate = true, prompt?: string ): void Basic If predicate is truthy the user will be prompted if they try to navigate away from the page, either by leaving the site or through \u0026lt;Link\u0026gt; or navigate being invoked.\nA standard prompt will be used if none is provided. Note: due to browser restrictions custom prompts are ignored when the user is trying to leave the site. Custom prompts will always work for in-site navigation from \u0026lt;Link\u0026gt; or navigate being invoked\nimport React, { useState } from \u0026#39;react\u0026#39; import { useNavigationPrompt, navigate } from \u0026#39;raviger\u0026#39; function Form({ isFormDirty }) { // When isFormDirty navigation will cause a confirm dialog  useNavigationPrompt(isFormDirty) return (/* */) "},{"uri":"https://kyeotic.github.io/raviger/api/usepath/","title":"usePath","tags":[],"description":"","content":" Get the current path of the page.\nAPI export function usePath(basePath?: string): string "},{"uri":"https://kyeotic.github.io/raviger/api/usebasepath/","title":"useBasePath","tags":[],"description":"","content":" Get the basePath set by a parent useRoutes component (empty string if none)\nAPI export function useBasePath(): string Basic import { useRoutes, useBasePath } from \u0026#39;raviger\u0026#39; function Home () { let basePath = useBasePath() // Will be \u0026#39;app\u0026#39; when render by the parent below  return \u0026lt;span\u0026gt;{basePath}\u0026lt;/span\u0026gt; } const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt; } export default function App() { return useRoutes(routes, { basePath: \u0026#39;app\u0026#39; }) ) } "},{"uri":"https://kyeotic.github.io/raviger/api/usehash/","title":"useHash","tags":[],"description":"","content":" A hook for getting the current hash of the page. Will cause re-renders when the hash changes.\nAPI export function useHash(options?: { stripHash?: boolean }): string stripHash If options.stripHash is true the hash will be returned without the literal \u0026ldquo;#\u0026rdquo; at the beginning. If you need the \u0026ldquo;#\u0026rdquo; set options.stripHash to false. default = true\n"},{"uri":"https://kyeotic.github.io/raviger/api/uselocationchange/","title":"useLocationChange","tags":[],"description":"","content":" This hook invokes a setter whenever the page location is updated.\nAPI export function useLocationChange( setFn: (path: string) =\u0026gt; any, options?: { inheritBasePath: boolean basePath: string isActive: () =\u0026gt; boolean | boolean } ): void Note: options.inheritBasePath is treated as true unless it is set to false (even if options is not provided), and takes precedence over options.basePath if true. If no BasePath is in the context to inherit options.basePath will be used as a fallback, if present.\nBasic The first parameter is a setter-function that is invoked with the new path whenever the url is changed. It does not automatically cause a re-render of the parent component (see re-rendering below).\nimport { useLocationChange } from \u0026#39;raviger\u0026#39; import { pageChanged } from \u0026#39;./monitoring\u0026#39; function App () { useLocationChange(pageChanged) return ( // ...  ) } You should try to provide the same function (referential-equality) to useLocationChange whenever possible. If you are unable to create the function outside the component scope use useCallback to get a memoized function.\nimport { useCallback } from \u0026#39;react\u0026#39; import { useLocationChange } from \u0026#39;raviger\u0026#39; import { pageChanged } from \u0026#39;./monitoring\u0026#39; function App () { const onChange = useCallback(path =\u0026gt; pageChanged(\u0026#39;App\u0026#39;, path), []) useLocationChange(onChange) return ( // ...  ) } Conditional Updates When options.isActive is both defined and falsey the setFn will not be invoked during location changes. If it is undefined or truthy setFn will be invoked.\nRe-rendering useLocationChange does not itself cause re-rendering. If you are trying to get the current path in your component that is better done with the usePath hook, which returns the value. However, it is possible to trigger re-rendering by combining useLocationChange with useState.\nimport { useState } from \u0026#39;react\u0026#39; import { useLocationChange } from \u0026#39;raviger\u0026#39; function Route () { const [path, setPath] = useState(\u0026#39;/\u0026#39;) useLocationChange(setPath) return ( // ...  ) } "},{"uri":"https://kyeotic.github.io/raviger/","title":"Documentation","tags":[],"description":"","content":" raviger React Navigator. A React hook-based router that updates on all url changes. Heavily inspired by hookrouter.\nZero dependencies. Tiny footprint.\nTo get started checkout the quickstart, or view the complete API docs\n"},{"uri":"https://kyeotic.github.io/raviger/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://kyeotic.github.io/raviger/tags/","title":"Tags","tags":[],"description":"","content":""}]