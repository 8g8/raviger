[{"uri":"https://kyeotic.github.io/raviger/api/useroutes/","title":"useRoutes","tags":[],"description":"","content":" This hook is the main entry point for an application using raviger.\nAPI function useRoutes( routes: { [key: string]: (props: { [k: string]: any }) =\u0026gt; JSX.Element }, options?: { basePath?: string routeProps?: { [k: string]: any } overridePathParams?: boolean matchTrailingSlash?: boolean } ): JSX.Element Basic The first parameter is an object of path keys whose values are functions that return a ReactElement (or null when no match is found). The paths should start with a forward-slash / and then contain literal matches (/base), path variables (/:userId), and a * for catch-all wildcards. Path variables will be provided to the matching route-function.\nimport { useRoutes, Link } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;User id={userId} /\u0026gt; } function NavBar () { return ( \u0026lt;div\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/1\u0026#34;\u0026gt;Tom\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/2\u0026#34;\u0026gt;Jane\u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; ) } export default function App() { let route = useRoutes(routes) return ( \u0026lt;div\u0026gt; \u0026lt;NavBar /\u0026gt; {route} \u0026lt;/div\u0026gt; ) } Using a Base Path The basePath option sets a base path that causes all routes to match as if they had the base path prepended to them. It also sets the base path on the router\u0026rsquo;s context, making it available to hooks and \u0026lt;Link\u0026gt; components lower in matching route\u0026rsquo;s tree.\nimport { useRoutes } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;User id={userId} /\u0026gt; } export default function App() { // For the path \u0026#34;/app/about\u0026#34; the \u0026lt;About\u0026gt; route will match  let route = useRoutes(routes, { basePath: \u0026#39;app\u0026#39; }) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } Sharing Props with routes The routeProps option can be used to pass data to the matching route. This is useful for sharing props that won\u0026rsquo;t appear in the route\u0026rsquo;s path, or reducing duplication in path parameter declarations.\nimport { useRoutes } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: ({ title }) =\u0026gt; \u0026lt;Home title={title} /\u0026gt;, \u0026#39;/about\u0026#39;: ({ title }) =\u0026gt; \u0026lt;About /\u0026gt; } export default function App() { let route = useRoutes(routes, { routeProps: { title: \u0026#39;App\u0026#39; } }) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } This can be combined with the overridePathParams option to provide a value that is used even if a path parameter would match for the route. IN this example if maybeGetUserId returns an ID it will be provided to the \u0026lt;User\u0026gt; component instead of the value from the path.\nimport { useRoutes } from \u0026#39;raviger\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;User id={userId} /\u0026gt; } export default function App() { let userId = maybeGetUserId() let route = useRoutes(routes, { routeProps: { userId }, overridePathParams: true }) return ( \u0026lt;div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } "},{"uri":"https://kyeotic.github.io/raviger/quickstart/","title":"Quick Start","tags":[],"description":"","content":" Quick Start Getting started with raviger\nInstallation npm i raviger  Quick Start This basic setup shows how to display an \u0026lt;App\u0026gt; component that renders a route based on the current path, with links to different routes.\nimport { useRoutes, Link, useQueryParams } from \u0026#39;raviger\u0026#39; import { Home, About, Users } from \u0026#39;./Pages.js\u0026#39; const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt;, \u0026#39;/about\u0026#39;: () =\u0026gt; \u0026lt;About /\u0026gt;, \u0026#39;/users/:userId\u0026#39;: ({ userId }) =\u0026gt; \u0026lt;Users id={userId} /\u0026gt; } export default function App() { let route = useRoutes(routes) return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Link href=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/1\u0026#34;\u0026gt;Tom\u0026lt;/Link\u0026gt; \u0026lt;Link href=\u0026#34;/users/2\u0026#34;\u0026gt;Jane\u0026lt;/Link\u0026gt; \u0026lt;/div\u0026gt; {route} \u0026lt;/div\u0026gt; ) } "},{"uri":"https://kyeotic.github.io/raviger/api/useredirect/","title":"useRedirect","tags":[],"description":"","content":" This hook causes a browser redirect to occur if its predicateUrl matches.\nAPI export function useRedirect( predicateUrl: string, targetUrl: string, queryParams?: QueryParam | URLSearchParams, replace?: boolean ): void Basic If predicateUrl is the current path, redirect to the targetUrl. queryObj is optional, and uses the same serializer that useQueryParams uses by default. If replace (default: true) it will replace the current URL (back button will skip the predicateUrl).\nimport { useRedirect } from \u0026#39;raviger\u0026#39; function Route () { // Will redirect to \u0026#39;/new\u0026#39; if current path is \u0026#39;/old\u0026#39;  useRedirect(\u0026#39;/old\u0026#39;, \u0026#39;/new\u0026#39;, { name: \u0026#39;kyeotic\u0026#39; }) return \u0026lt;span\u0026gt;Home\u0026lt;/span\u0026gt; } "},{"uri":"https://kyeotic.github.io/raviger/api/","title":"API","tags":[],"description":"","content":" API Explore the raviger API\n"},{"uri":"https://kyeotic.github.io/raviger/api/link/","title":"Link","tags":[],"description":"","content":" A React component for rendering a \u0026lt;a\u0026gt; that uses history navigation for local URLs.\nAPI export interface LinkProps extends React.AnchorHTMLAttributes\u0026lt;HTMLAnchorElement\u0026gt; { // Unlike normal \u0026lt;a\u0026gt;, this property is required  href: string } export const Link: React.FC\u0026lt;LinkProps\u0026gt; Basic This component is the preferred method of navigation, alongside the navigate function.\nThis component takes all the same parameters as the built-in \u0026lt;a\u0026gt; tag. It\u0026rsquo;s onClick will be extended to perform local navigation, and if it is inside a component returned from useRoutes it will have the provided basePath preprended to its href.\n\u0026lt;Link href=\u0026#34;/foo\u0026#34;\u0026gt; go to foo \u0026lt;/Link\u0026gt; "},{"uri":"https://kyeotic.github.io/raviger/api/activelink/","title":"ActiveLink","tags":[],"description":"","content":" Like the standard Link component, but with built-in className transormation when a matching path is detected.\nAPI export interface ActiveLinkProps extends LinkProps { activeClass?: string exactActiveClass?: string } export const ActiveLink: React.FC\u0026lt;ActiveLinkProps\u0026gt; Basic Just like \u0026lt;Link\u0026gt;, but with two additional properties for modifying the className\n activeClass If the href matches the start of the current path this will be appended to the \u0026lt;a\u0026gt; className. exactActiveClass If the href matches the cirrent path exactly this will be appended to the \u0026lt;a\u0026gt; className. Stacks with activeClass  \u0026lt;ActiveLink href=\u0026#34;/foo\u0026#34; activeClass=\u0026#34;when-path-is-prefix\u0026#34; exactActiveClass=\u0026#34;when-path-is-exact\u0026#34; \u0026gt; go to foo \u0026lt;/ActiveLink\u0026gt; "},{"uri":"https://kyeotic.github.io/raviger/api/navigate/","title":"navigate","tags":[],"description":"","content":" This function causes programmatic navigation and causes all raviger hooks to re-render. Internally it used by the \u0026lt;Link\u0026gt; component.\nAPI export function navigate(url: string, replace?: boolean): void export function navigate( url: string, query?: QueryParam | URLSearchParams, replace?: boolean ): void Basic the navigate function is intended to be used outside of components to perform page navigation programmatically.\nimport { navigate } from \u0026#39;raviger\u0026#39; export async function createUser () { let user = await createUser() navigate(`/users/${user.id}`) } Normal navigation adds an entry to the browsers history stack, enabling the back button to return to the previous location. To instead change the page without adding to the history stack use the replace option. This is sometimes desirable when creating objects as the creation-page form may no longer be a valid location\nimport { navigate } from \u0026#39;raviger\u0026#39; export async function createUser () { let user = await createUser() navigate(`/users/${user.id}`, true) } Navigating with Query Params To navigate with a serialized query string pass an object as the second parameter.\nimport { navigate } from \u0026#39;raviger\u0026#39; export async function createUser () { let user = await createUser() navigate(`/users/${user.id}` { ref: \u0026#39;create page\u0026#39; }) } "},{"uri":"https://kyeotic.github.io/raviger/api/usequeryparams/","title":"useQueryParams","tags":[],"description":"","content":" A hook for reading and updating the query string parameters on the page. Updates on all URL changes. Returns an array that, much like React\u0026rsquo;s own useState, has a value and a setter function. The value is a parsed querystring object, and the setter takes an object that it will serialize into the query string.\nAPI export function useQueryParams( parseFn?: (query: string) =\u0026gt; QueryParam, serializeFn?: (query: QueryParam) =\u0026gt; string ): [QueryParam, (query: QueryParam, replace?: boolean) =\u0026gt; void] Basic The default parse and serialize functions utilized the browser built-in URLSearchParams. You can provide custom parse and serialize functions to control this behavior.\nimport { useQueryParams } from \u0026#39;raviger\u0026#39; function UserList ({ users }) { const [{ startsWith }, setQuery] = useQueryParams() return ( \u0026lt;div\u0026gt; \u0026lt;label\u0026gt; Filter by Name \u0026lt;input value={startsWith || \u0026#39;\u0026#39;} onChange={(e) =\u0026gt; setQuery({ startsWith: e.target.value})} /\u0026gt; \u0026lt;/label\u0026gt; {users.filter(u =\u0026gt; !startsWith || u.name.startsWith(startsWith).map(user =\u0026gt; ( \u0026lt;p key={user.name}\u0026gt;{user.name}\u0026lt;/p\u0026gt; )))} \u0026lt;/div\u0026gt; ) } Updating the Query with merge The second return value from useQueryParams is a function that updates the query string. By default it overwrites the entire query, but it can merge with the query object by setting the second param to true.\nimport { useQueryParams } from \u0026#39;raviger\u0026#39; function UserList ({ users }) { const [{ startsWith }, setQuery] = useQueryParams() return ( \u0026lt;input value={startsWith || \u0026#39;\u0026#39;} onChange={(e) =\u0026gt; setQuery({ startsWith: e.target.value}, true )} /\u0026gt; ) } Custom serialization and parsing Its possible to override either the querystring serializer, deserializer, or both, by providing functions to useQueryParams. Use a custom wrapper hook to reuse throughout your application.\nimport { useQueryParams } from \u0026#39;raviger\u0026#39; import qs from \u0026#39;qs\u0026#39; export function useCustomQuery() { return useQueryParams(qs.parse, qs.stringify) }  "},{"uri":"https://kyeotic.github.io/raviger/api/usepath/","title":"usePath","tags":[],"description":"","content":" Get the current path of the page.\nAPI export function usePath(basePath?: string): string "},{"uri":"https://kyeotic.github.io/raviger/api/usebasepath/","title":"useBasePath","tags":[],"description":"","content":" Get the basePath set by a parent useRoutes component (empty string if none)\nAPI export function useBasePath(): string Basic import { useRoutes, useBasePath } from \u0026#39;raviger\u0026#39; function Home () { let basePath = useBasePath() // Will be \u0026#39;app\u0026#39; when render by the parent below  return \u0026lt;span\u0026gt;{basePath}\u0026lt;/span\u0026gt; } const routes = { \u0026#39;/\u0026#39;: () =\u0026gt; \u0026lt;Home /\u0026gt; } export default function App() { return useRoutes(routes, { basePath: \u0026#39;app\u0026#39; }) ) } "},{"uri":"https://kyeotic.github.io/raviger/","title":"","tags":[],"description":"","content":" raviger React Navigator. A React hook-based router that updates on all url changes. Heavily inspired by hookrouter.\nZero dependencies. Tiny footprint.\n"},{"uri":"https://kyeotic.github.io/raviger/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://kyeotic.github.io/raviger/tags/","title":"Tags","tags":[],"description":"","content":""}]